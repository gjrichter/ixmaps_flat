/** 
 * @fileoverview
 * provides an object and methods to load, parse and process various data sources.<br>
 * The <b>sources</b> may be of the following type: <b>csv</b>, <b>json</b>, <b>geojson</b>, <b>kml</b>, <b>gml</b>, <b>rss</b>, and <b>parquet</b> (using DuckDB WASM).<br>
 * The <b>methods</b> to load data are: 
 * <ul><li>Data.<b>feed()</b> to load from url</li>
 * <li>Data.<b>import()</b> to import javascript objects and</li>
 * <li>Data.<b>broker()</b> to load more than one source</li></ul>
 * The loaded data is stored in a Table object which gives the user the methods to transform the data.<br>
 * The format of the data of a Table object is jsonDB, the same format used internaly by iXmaps.
 * @example 
 *
 *  // define data source
 *  var szUrl = "https://raw.githubusercontent.com/emergenzeHack/terremotocentro/master/_data/issues.csv";
 *
 *  // load data from feed
 *  var myfeed = Data.feed({"source":szUrl,"type":"csv"}).load(function(mydata){
 *
 *      // on data load succeeds, process the loaded data via mydata object
 *      // create new columns 'date' and 'hour' from one timestamp column
 *      // we need them to create pivot tables 
 *      // ---------------------------------------------------------------
 *      mydata.addColumn({'source':'created_at','destination':'date'},function(value){
 *          var d = new Date(__normalizeTime(value));
 *          return( String(d.getDate()) + "." + String(d.getMonth()+1) + "." + String(d.getFullYear()) );
 *      });
 *
 *      // get the hours
 *      // -----------------------------------------
 *      var hoursA = mydata.column("hour").values();
 *
 *      // do something ... 
 *
 *      // make a pivot table from the values in column 'state'
 *      // ----------------------------------------------------
 *      var pivot = mydata.pivot({ "lead":	'date',
 *                                 "keep":  ['created_at'],	
 *                                 "cols":	'state' 
 *                               });
 *
 *      // invert data table (let the last record be the first)
 *      // ----------------------------------------------
 *      pivot = pivot.revert();
 *
 *      // make chart with 2 curves, total and closed issues
 *      // -------------------------------------------------
 *      var set1  = pivot.column("Total").values();
 *      var set2  = pivot.column("closed").values();
 *
 *     ....
 * }).error(function(e){
 *      alert("Data.feed error: " + e);
 * });
 *
 * @author Guenter Richter guenter.richter@medienobjekte.de
 * @version 1.56 
 * @copyright CC BY SA
 * @license MIT
 */
!function(e,t,o){new Date;_LOG=function(e){new Date};const r=function(e){return e&&void 0!==e?function(e){return"[object Array]"===Object.prototype.toString.call(e)}(e)?e:String(e).match(/\|/)?String(e).split("|"):String(e).split(","):[]},s=function(e,t,o){return o.indexOf(e)===t};var n={version:"1.56",errors:[],log:function(e){}};"object"==typeof module&&"object"==typeof module.exports?module.exports=n:"function"==typeof define&&define.amd&&define(n),void 0!==e&&function(){const t=e.Data;n.noConflict=function(){return e.Data=t,this},e.Data=n}(),n.Object=function(e){this.options=e,this.debug=!1},n.Object.prototype={import:function(e){return this.options.success=this.options.success||e,this.feed=n.feed({}),this.feed.options=this.options,"csv"==this.options.type||"CSV"==this.options.type?this.feed.__processCSVData(this.options.source,this.options):"rss"==this.options.type||"RSS"==this.options.type?(this.options.format="xml",this.feed.__processRSSData(this.options.source,this.options)):"kml"==this.options.type||"KML"==this.options.type?(this.options.format="xml",this.feed.__processKMLData(this.options.source,this.options)):"gml"==this.options.type||"GML"==this.options.type?(this.options.format="xml",this.feed.__processGMLData(this.options.source,this.options)):"json"==this.options.type||"JSON"==this.options.type||"Json"==this.options.type?this.feed.__processJsonData(this.options.source,this.options):"geojson"==this.options.type||"GEOJSON"==this.options.type||"GeoJson"==this.options.type?this.feed.__processGeoJsonData(this.options.source,this.options):"topojson"==this.options.type||"TOPOJSON"==this.options.type||"TopoJson"==this.options.type?this.feed.__processTopoJsonData(this.options.source,this.options):"jsonDB"==this.options.type||"JSONDB"==this.options.type||"JsonDB"==this.options.type||"jsondb"==this.options.type?this.feed.__processJsonDBData(this.options.source,this.options):"parquet"==this.options.type||"PARQUET"==this.options.type?this.options.source instanceof ArrayBuffer&&(_LOG("Processing parquet ArrayBuffer directly: "+this.options.source.byteLength+" bytes"),this.feed.__processParquetData(this.options.source,this.options)):"geoparquet"!=this.options.type&&"GEOPARQUET"!=this.options.type||this.options.source instanceof ArrayBuffer&&(_LOG("Processing geoparquet ArrayBuffer directly: "+this.options.source.byteLength+" bytes"),this.feed.__processGeoParquetData(this.options.source,this.options)),this},error:function(e){return this.options.error=e,this}},n.Import=function(e){this.options=e,this.debug=!1},n.Feed=function(e){this.options=e||{},this.debug=!1,this.options.error=function(e){n.errors.push(e)}},n.Feed.prototype={load:function(e){this.options.success=e;const t=this.options,o=t.source||t.src||t.url||t.ext;void 0===t.cache&&(t.cache=!0,t.options&&void 0!==t.options.cache&&(t.cache=t.options.cache));const r=this;return o||a("Data.feed(...).load(): no source defined !",2e3),"csv"==t.type||"CSV"==t.type?this.__doCSVImport(o,t):"rss"==t.type||"RSS"==t.type?this.__doRSSImport(o,t):"kml"==t.type||"KML"==t.type?this.__doKMLImport(o,t):"gml"==t.type||"GML"==t.type?this.__doGMLImport(o,t):"json"==t.type||"JSON"==t.type||"Json"==t.type?this.__doJSONImport(o,t):"geojson"==t.type||"GEOJSON"==t.type||"GeoJson"==t.type?this.__doGeoJSONImport(o,t):"topojson"==t.type||"TOPOJSON"==t.type||"TopoJson"==t.type?this.__doTopoJSONImport(o,t):"jsonDB"==t.type||"JSONDB"==t.type||"JsonDB"==t.type||"jsondb"==t.type?this.__doJsonDBImport(o,t):"jsonstat"==t.type||"jsonStat"==t.type||"JSONSTAT"==t.type?$.getScript("http://json-stat.org/lib/json-stat.js").done((function(e,s){r.__doLoadJSONstat(o,t)})).fail((function(e,o,r){a("'"+t.type+"' unknown format !")})):"parquet"==t.type||"PARQUET"==t.type?this.__doParquetImport(o,t):a("'"+t.type+"' unknown format !"),this},error:function(e){return this.options.error=e,this}},n.feed=function(e){return new n.Feed(e)},n.object=function(e){return new n.Object(e)},n.import=function(e){return new n.Object(e).import().feed.dbtable};n.Feed.prototype.__doLoadJSONstat=function(e,t){const o=this;JSONstat(e,(function(){const e=[];let r=[this.Dataset(0).Dimension(0).label];const s=this.Dataset(0).Dimension(1).id;for(let e=0;e<s.length;e++)r.push(this.Dataset(0).Dimension(1).Category(s[e]).label);e.push(r);for(let t=0;t<this.Dataset(0).Dimension(0).length;t++){r=[],r.push(this.Dataset(0).Dimension(0).Category(this.Dataset(0).Dimension(0).id[t]).label);for(let e=0;e<this.Dataset(0).Dimension(1).length;e++)r.push(this.Dataset(0).Data([t,e]).value);e.push(r)}t.callback?t.callback(e,t):o.__createDataTableObject(e,t.type,t)}))},n.Feed.prototype.__doJsonDBImport=function(e,t){_LOG("__doJsonDBImport: "+e);const o=this;t.url=e,$.getScript(e+".gz").done((function(e,r){o.__processJsonDBData(e,t)})).fail((function(r,s,n){$.getScript(e).done((function(e,r){o.__processJsonDBData(e,t)})).fail((function(t,r,s){o.options.error&&o.options.error('"'+e+'" '+s)}))}))},n.Feed.prototype.__processJsonDBData=function(t,o){_LOG("__processJsonDBData:"),this.dbtable=new n.Table;let r=null;if("string"==typeof t){const t=o.source.split(/\//).pop().split(/\./)[0];r=void 0!==e?e[t]:global[t]}else r=o.source;this.dbtable.table=r.table,this.dbtable.fields=r.fields,this.dbtable.records=r.records,o.callback?o.callback(newData,o):void 0!==o&&o.success&&o.success(this.dbtable)},n.Feed.prototype.__doCSVImport=function(e,t){_LOG("__doCSVImport: "+e);const o=this;$.ajax({type:"GET",url:e,cache:t.cache,dataType:"text",success:function(e){o.__processCSVData(e,t)},error:function(o,r,s){void 0!==t&&t.error&&t.error('"'+e+'" '+s)}})},n.Feed.prototype.__processCSVData=function(e,t){if(_LOG("__processCSVData - start"),"undefined"==typeof Papa){_LOG("__processCSVData:load csv parser!");const o=this;return $.getScript("https://cdnjs.cloudflare.com/ajax/libs/PapaParse/4.1.2/papaparse.min.js").done((function(r,s){o.__processCSVData(e,t)})).fail((function(e,o,r){a("'"+t.type+"' parser not loaded !"),t.error&&t.error("'"+t.type+"' parser not loaded !")})),!1}let o=Papa.parse(e,t.parser);if(o.errors.length)return a("csv parsing error: "+o.errors.map((e=>e.message)).join(";")),t.error&&t.error("csv parsing error: "+o.errors.map((e=>e.message)).join(";")),!1;let r=o.data;if(r.length<2||void 0===r[0]||void 0===r[1])return a("csv parsing error: insufficient rows in data !"),t.error&&t.error("csv parsing error: insufficient rows in data !"),!1;if(!(t.parser&&t.parser.delimiter||r[0].length===r[1].length)){_LOG("csv parser: autodetect failed");const o=[";",","];let s=!1;for(const t of o){if(_LOG(`csv parser: delimiter = ${t}`),r=Papa.parse(e,{delimiter:t}).data,r[0].length===r[1].length){s=!0;break}_LOG(`csv parser: delimiter = ${t} failed`)}if(!s)return a("csv parsing error: unable to auto detect delimiter!"),t.error&&t.error("csv parsing error: unable to auto detect delimiter!"),!1}return r[r.length-1].length!==r[0].length&&r.length>1&&r.pop(),r[0].length-r[1].length==1&&""===r[0][r[0].length-1].trim()&&r[0].pop(),t.callback?(t.callback(r,t),!1):(_LOG("__createDataTableObject: "+(t.options?" -> "+t.options.name:"")),this.__createDataTableObject(r,t.type,t),!1)},n.Feed.prototype.__doRSSImport=function(e,t){_LOG("__doRSSImport: "+e);const o=this;t.format="xml",$.ajax({type:"GET",url:e,dataType:"xml",success:function(e){o.__processRSSData(e,t)},error:function(e,o,r){void 0!==t&&t.error&&t.error(e,o,r)}})},n.Feed.prototype.__processRSSData=function(e,t){"xml"==t.format&&($(e).find("rss").length?this.__parseRSSData(e,t):$(e).find("feed").length?a("feed not yet supported"):$(e).find("atom").length&&a("atom not yet supported"))},n.Feed.prototype.__parseRSSData=function(e,t){const o=this;"xml"==t.format&&$(e).find("channel").each((function(){const r=[];let s=null;$(e).find("item").each((function(){if(!s){const e=[];s=[];const t=$(this).children();for(let o=0;o<t.length;o++){let t=$(this).children()[o].nodeName;for(;e[t];)t+="*";e[t]=t,s[o]=t}r.push(s)}const e=[];for(let t=0;t<s.length;t++)"enclosure"==s[t]?e.push($(this).find(s[t]+":first").attr("url")||""):e.push($(this).find(s[t]+":first").text()||"");r.push(e)})),o.__createDataTableObject(r,"rss",t)}))},n.Feed.prototype.__doKMLImport=function(e,t){_LOG("__doKMLImport: "+e);const o=this;t.format="xml",$.ajax({type:"GET",url:e,dataType:"xml",success:function(e){o.__processKMLData(e,t)},error:function(e,o,r){void 0!==t&&t.error&&t.error(e,o,r)}})},n.Feed.prototype.__doGMLImport=function(e,t){_LOG("__doGMLImport: "+e);const o=this;t.format="xml",$.ajax({type:"GET",url:e,dataType:"xml",success:function(e){o.__processGMLData(e,t)},error:function(e,o,r){void 0!==t&&t.error&&t.error(e,o,r)}})},n.Feed.prototype.__processKMLData=function(e,t){"xml"==t.format&&($(e).find("kml").length?this.__parseKMLData(e,t):a("feed not kml"))},n.Feed.prototype.__parseKMLData=function(e,t){const o=this;if("xml"==t.format){const r=$(e).find("Document"),s=[];let n=null;r.find("Placemark").each((function(){const e=$(this).find("ExtendedData")||$(this);n||(n=[],e.find("Data").each((function(){n.push($(this).attr("name"))})),$(this).find("Point").find("coordinates")&&n.push("KML.Point"),s.push(n));const t=[];e.find("Data").each((function(){t.push($(this).find("value").text())})),$(this).find("Point").find("coordinates")&&t.push($(this).find("Point").find("coordinates").text()),s.push(t)})),o.__createDataTableObject(s,"kml",t)}},n.Feed.prototype.__processGMLData=function(e,t){"xml"==t.format&&("string"==typeof e&&(parser=new DOMParser,e=parser.parseFromString(e,"text/xml")),$(e).find("wfs\\:FeatureCollection, gml\\:FeatureCollection, FeatureCollection").length?this.__parseGMLData(e,t):a("feed not gml"))},n.Feed.prototype.__parseGMLData=function(e,t){const o=this;if("xml"==t.format){const r=$(e).find("wfs\\:FeatureCollection, FeatureCollection").first();if(0===r.length)return void a("No FeatureCollection found in GML data");const s=[];let n=null;r.find("wfs\\:member, gml\\:featureMember, featureMember, gml\\:featureMembers, featureMembers").each((function(){const e=$(this).find("gml\\:*, *").first();if(0===e.length)return;n||(n=[],e.find("gml\\:*, *").each((function(){const e=$(this).prop("tagName");e&&!e.match(/^(gml:)?(boundedBy|location|pos|coordinates|geometry|geometryProperty)$/i)&&n.push(e.replace(/^gml:/,""))})),n.push("GML.Geometry"),s.push(n));const t=[];e.find("gml\\:*, *").each((function(){const e=$(this).prop("tagName");e&&!e.match(/^(gml:)?(boundedBy|location|pos|coordinates|geometry|geometryProperty)$/i)&&t.push($(this).text())}));const o=e.find("gml\\:Polygon").first();if(o.length>0){let e='{"type":"Polygon","coordinates":[[',s=o.text().split(" "),n=0;for(var r=0;r<s.length;r++)if(Number(s[r])&&!isNaN(Number(s[r]))){n=r;break}if(n<s.length-1)for(r=n;r<s.length-1;r+=2)s[r]&&s[r+1]&&!isNaN(Number(s[r]))&&!isNaN(Number(s[r+1]))&&(e+=(r>n?",":"")+"["+s[r+1]+","+s[r]+"]");e+="]]}",t.push(e)}else t.push("");s.push(t)})),o.__createDataTableObject(s,"gml",t)}},n.Feed.prototype.__doJSONImport=function(e,t){const o=this;$.get(e,(function(e){o.__processJsonData(e,t)})).fail((function(e){void 0!==t&&t.error&&t.error(e)}))},__getNestedPaths=function(e,t=""){const o=[];if("object"!=typeof e||null===e||Array.isArray(e))Array.isArray(e)?e.forEach(((e,r)=>{const s=t?`${t}.${r}`:String(r);o.push(...__getNestedPaths(e,s))})):o.push(t);else for(const r in e)if(Object.prototype.hasOwnProperty.call(e,r)){const s=e[r],n=t?`${t}.${r}`:r;o.push(...__getNestedPaths(s,n))}return o},__extractValuesRecursive=function(e,t){let r=[];if(null==e)r.push("null");else if("object"!=typeof t||null===t||Array.isArray(t))if(Array.isArray(t))for(let s=0;s<t.length;s++){const n=s<e.length?e[s]:o;r=r.concat(__extractValuesRecursive(n,t[s]))}else r.push(e);else for(const s in t)if(Object.prototype.hasOwnProperty.call(t,s)){const n=Object.prototype.hasOwnProperty.call(e,s)?e[s]:o;r=r.concat(__extractValuesRecursive(n,t[s]))}return r},n.Feed.prototype.__processJsonData=function(e,t){let o=null;if("string"==typeof e)try{o=JSON.parse(e)}catch(e){this.__createDataTableObject([],"json",t)}else o=e;this.data=o;let r=[],s=[];if(o&&o.data&&o.data.columns&&o.data.rows){const e=o.data.columns,t=o.data.rows;for(let t=0,o=e.length;t<o;t++)s.push(e[t]);r.push(s);for(let e=0,o=t.length;e<o;e++){s=[];for(let o=0,r=t[0].length;o<r;o++)s.push(t[e][o]);r.push(s)}}else{if(o&&o.data&&(o=o.data),!Array.isArray(o)){__findAllArraysInJson=function(e){const t=[];return function e(o){if(Array.isArray(o))t.push(o);else if("object"==typeof o&&null!==o)for(const t in o)o.hasOwnProperty(t)&&e(o[t])}(e),t},o=__findAllArraysInJson(o)[0]}if(!o){let o=[];o.push(["unknown type"]);const r=e.split("\n");for(let e=0,t=r.length;e<t;e++)o.push([r[e]]);return void this.__createDataTableObject(o,"json",t)}r.push(__getNestedPaths(o[0]));for(let e=0;e<o.length;e++)r.push(__extractValuesRecursive(o[e],o[0]))}this.__createDataTableObject(r,"json",t)},n.Feed.prototype.__doGeoJSONImport=function(e,t){const o=this;$.get(e,(function(e){o.__processGeoJsonData(e,t)})).fail((function(e){void 0!==t&&t.error&&t.error(e)}))},n.Feed.prototype.__processGeoJsonData=function(e,t){let r=null;if("string"==typeof e)try{r=JSON.parse(e)}catch(e){return void this.__createDataTableObject([],"json",t)}else r=e;this.data=r;const s=[],n={};if(r&&r.features&&r.features.length){for(const e of r.features)if(e.properties)for(const t in e.properties)n[t]=!0;const e=Object.keys(n);e.push("geometry"),s.push(e);for(const t of r.features){const r=[],n=t.properties||{};for(let t=0;t<e.length-1;t++){const s=n[e[t]];"object"==typeof s?r.push(JSON.stringify(s)):r.push(s!==o?s:"")}r.push(JSON.stringify(t.geometry)),s.push(r)}}this.__createDataTableObject(s,"json",t)},n.Feed.prototype.__processGeoJsonData_expandProperty=function(e,t){let o=null;if("string"==typeof e)try{o=JSON.parse(e)}catch(e){this.__createDataTableObject([],"json",t)}else o=e;this.data=o;let r=[],s=[];const n=[];if(o&&o.features&&o.features.length){for(let e=0;e<o.features.length;e++)for(const t in o.features[e].properties)if("string"==typeof o.features[e].properties[t]||"number"==typeof o.features[e].properties[t])n[t]=!0;else for(const r in o.features[e].properties[t])n[t+"."+r]=!0;for(const e in n)s.push(e);s.push("geometry"),r.push(s);for(let e=0;e<o.features.length;e++){s=[];for(let t=0;t<r[0].length-1;t++){const n=r[0][t].split(".");n.length>=2?s.push(o.features[e].properties[n[0]][n[1]]||""):s.push(o.features[e].properties[r[0][t]]||"")}s.push(JSON.stringify(o.features[e].geometry)),r.push(s)}}this.__createDataTableObject(r,"json",t)},n.Feed.prototype.__doTopoJSONImport=function(e,t){const o=this;$.get(e,(function(e){o.__processTopoJsonData(e,t)})).fail((function(e){void 0!==t&&t.error&&t.error(e)}))},n.Feed.prototype.__processTopoJsonData=function(e,t){if("undefined"==typeof topojson)return void a("'"+t.type+"' parser not loaded !");let o=null;if("string"==typeof e)try{o=JSON.parse(e)}catch(e){this.__createDataTableObject([],"json",t)}else o=e;this.data=o;let r=null;if(t.options&&t.options.name&&o.objects[t.options.name])r=topojson.feature(o,o.objects[t.options.name]);else for(var s in o.objects){r=topojson.feature(o,o.objects[s]);break}for(const e in r.features)r.features[e].properties.id=r.features[e].id;this.__processGeoJsonData(r,t)},n.Feed.prototype.__doParquetImport=function(e,t){_LOG("__doParquetImport: "+e);const o=this;_LOG("Attempting to load parquet file using Fetch API..."),fetch(e,{method:"GET",cache:t.cache?"default":"no-cache"}).then((e=>{if(_LOG("Fetch response received, status: "+e.status),_LOG("Response headers: "+JSON.stringify([...e.headers.entries()])),!e.ok)throw new Error(`HTTP ${e.status}: ${e.statusText}`);return e.arrayBuffer()})).then((e=>{_LOG("Successfully loaded parquet as ArrayBuffer: "+e.byteLength+" bytes");const r=new Uint8Array(e);if(r.length>=4){const s=String.fromCharCode(...r.slice(0,4));_LOG("Magic number: "+s),"PAR1"===s?(_LOG("✅ SUCCESS: Valid parquet file detected!"),o.__processParquetData(e,t)):(_LOG("⚠️ Warning: Magic number is not PAR1: "+s),_LOG("First 16 bytes: "+Array.from(r.slice(0,16)).map((e=>e.toString(16).padStart(2,"0"))).join(" ")),_LOG("Attempting to process anyway..."),o.__processParquetData(e,t))}else _LOG("⚠️ Warning: Response too short to check magic number"),o.__processParquetData(e,t)})).catch((r=>{_LOG("Fetch failed: "+r.message),_LOG("Falling back to XMLHttpRequest..."),o.__loadParquetWithXHR(e,t)}))},n.Feed.prototype.__loadParquetWithXHR=function(e,t){const o=this;_LOG("Loading parquet with XMLHttpRequest...");const r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=function(){if(200===r.status){const e=r.response;_LOG("XHR successful: "+e.byteLength+" bytes");const s=new Uint8Array(e);if(s.length>=4){const r=String.fromCharCode(...s.slice(0,4));_LOG("XHR magic number: "+r),"PAR1"===r?(_LOG("✅ SUCCESS: Valid parquet file via XHR!"),o.__processParquetData(e,t)):(_LOG("⚠️ Warning: XHR magic number is not PAR1: "+r),_LOG("First 16 bytes: "+Array.from(s.slice(0,16)).map((e=>e.toString(16).padStart(2,"0"))).join(" ")),_LOG("Attempting to process anyway..."),o.__processParquetData(e,t))}else _LOG("⚠️ Warning: XHR response too short to check magic number"),o.__processParquetData(e,t)}else _LOG("XHR failed with status: "+r.status+" "+r.statusText),void 0!==t&&t.error?t.error("XHR failed: "+r.status+" "+r.statusText):a("XHR failed: "+r.status+" "+r.statusText)},r.onerror=function(){_LOG("XHR network error"),void 0!==t&&t.error?t.error("XHR network error"):a("XHR network error")},r.send()},n.Feed.prototype.__checkGeoParquetMetadataWithDuckDB=function(t,o,r){try{const r=t.slice(),s="temp_parquet_"+Date.now()+".parquet";e.duckdb.db.registerFileBuffer(s,new Uint8Array(r)).then((function(){const t=`\n                        SELECT * FROM read_parquet('${s}') LIMIT 1\n                    `;return e.duckdb.conn.query(t)})).then((function(e){let t,r=!1;if("function"==typeof e.toArray)t=e.toArray();else if("function"==typeof e.fetchAll)t=e.fetchAll();else if(Array.isArray(e))t=e;else{if(!e.data||!Array.isArray(e.data))return void o(!1);t=e.data}if(t&&t.length>0){const e=t[0],o=Object.keys(e),s=["geometry","geom","the_geom","wkb_geometry","shape"];for(const e of o){const t=e.toLowerCase();if(s.includes(t)){r=!0;break}}for(const e of o){const t=e.toLowerCase();if(t.includes("wkb")||t.includes("geojson")||t.includes("wkt")||t.includes("coordinates")){r=!0;break}}}o(r)})).catch((function(e){o(!1)})).finally((function(){try{e.duckdb.db.dropFile(s)}catch(e){}}))}catch(e){r(e)}},n.Feed.prototype.__detectColumnTypes=function(e){if(!e||!e.fields)return null;return e.fields.map((e=>{const t=e.type.toString().toLowerCase(),o=e.name.toLowerCase();let r;return r=t.includes("geometry")||t.includes("wkb")||t.includes("wkt")||t.includes("blob")||t.includes("binary")||"geometry"===o||"geom"===o||"wkb_geometry"===o||"wkt_geometry"===o||o.includes("shape")?"geometry":t.includes("list")||t.includes("array")?"array":t.includes("utf8")||t.includes("string")||t.includes("varchar")?"string":t.includes("int")||t.includes("float")||t.includes("double")||t.includes("decimal")?"number":t.includes("bool")?"boolean":t.includes("date")||t.includes("timestamp")?"date":"other","geometry"===r?n.log(`🗺️ Detected geometry column: "${e.name}" (type: ${t})`):"array"===r&&n.log(`📋 Detected array column: "${e.name}" (type: ${t})`),r}))},n.Feed.prototype.__convertGeometryToGeoJSON=function(e){if(!e)return"";try{if(e instanceof ArrayBuffer||e instanceof Uint8Array){const t=e instanceof Uint8Array?e:new Uint8Array(e);return this.__parseWKB(t)}return"string"==typeof e?e.match(/^(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION)\s*\(/i)?this.__wktToGeoJSON(e):(e.trim().startsWith("{"),e):"object"==typeof e?JSON.stringify(e):String(e)}catch(t){try{return JSON.stringify(e)}catch(t){return String(e||"")}}},n.Feed.prototype.__parseWKB=function(e){try{if(e.length<5)return"";const t=1===e[0],o=new DataView(e.buffer,e.byteOffset,e.byteLength),r=o.getUint32(1,t);switch(r){case 1:return this.__parseWKBPoint(o,t);case 2:return this.__parseWKBLineString(o,t);case 3:return this.__parseWKBPolygon(o,t);case 4:case 5:case 6:case 7:const s=Array.from(e).map((e=>e.toString(16).padStart(2,"0"))).join("");return JSON.stringify({type:"WKB",wkb:s,geomType:r});default:const n=Array.from(e).map((e=>e.toString(16).padStart(2,"0"))).join("");return JSON.stringify({type:"WKB",wkb:n,geomType:r})}}catch(t){const o=Array.from(e).map((e=>e.toString(16).padStart(2,"0"))).join("");return JSON.stringify({type:"WKB",wkb:o})}},n.Feed.prototype.__parseWKBPoint=function(e,t){const o=e.getFloat64(5,t),r=e.getFloat64(13,t);return JSON.stringify({type:"Point",coordinates:[o,r]})},n.Feed.prototype.__parseWKBLineString=function(e,t){const o=e.getUint32(5,t),r=[];for(let s=0;s<o;s++){const o=9+16*s,n=e.getFloat64(o,t),i=e.getFloat64(o+8,t);r.push([n,i])}return JSON.stringify({type:"LineString",coordinates:r})},n.Feed.prototype.__parseWKBPolygon=function(e,t){const o=e.getUint32(5,t),r=[];let s=9;for(let n=0;n<o;n++){const o=e.getUint32(s,t);s+=4;const n=[];for(let r=0;r<o;r++){const o=e.getFloat64(s,t),r=e.getFloat64(s+8,t);n.push([o,r]),s+=16}r.push(n)}return JSON.stringify({type:"Polygon",coordinates:r})},n.Feed.prototype.__wktToGeoJSON=function(e){try{const t=e.match(/POINT\s*\(\s*([^\s]+)\s+([^\s]+)\s*\)/i);return t?JSON.stringify({type:"Point",coordinates:[parseFloat(t[1]),parseFloat(t[2])]}):JSON.stringify({type:"WKT",wkt:e})}catch(t){return e}},n.Feed.prototype.__convertValue=function(e,t){if(null==e)return"";if(t)switch(t){case"geometry":return this.__convertGeometryToGeoJSON(e);case"array":if(Array.isArray(e))return JSON.stringify(e);if(e&&"object"==typeof e&&"function"==typeof e.toArray)return JSON.stringify(e.toArray());if(e&&"object"==typeof e)try{return JSON.stringify(Array.from(e))}catch(t){return JSON.stringify(e)}return String(e);case"string":return e;case"number":case"boolean":return String(e);case"date":return e instanceof Date?e.toISOString():String(e);default:return"string"==typeof e?e:"object"==typeof e?JSON.stringify(e):String(e)}else{if("string"==typeof e)return e;if("number"==typeof e||"boolean"==typeof e)return String(e);if(e instanceof Date)return e.toISOString();if(Array.isArray(e))return JSON.stringify(e);if(e&&"object"==typeof e&&"function"==typeof e.toArray)try{return JSON.stringify(e.toArray())}catch(t){return JSON.stringify(e)}else try{return JSON.stringify(e)}catch(t){return String(e)}}},n.Feed.prototype.__processRow=function(e,t,o,r,s){const n=new Array(t.length);for(let i=0;i<t.length;i++){let a;a=r?e[i]:s?e[t[i]]:e,n[i]=this.__convertValue(a,o?o[i]:null)}return n},n.Feed.prototype.__createParquetWorker=function(){const e=new Blob(["\n            // Web Worker for processing parquet data\n            self.onmessage = function(e) {\n                const { rows, columns, isArrayFormat, isObjectFormat, batchSize } = e.data;\n                \n                try {\n                    const cellsPerRow = columns.length;\n                    const totalRows = rows.length;\n                    let processedRows = 0;\n                    \n                    // Process data in batches\n                    for (let batchStart = 0; batchStart < totalRows; batchStart += batchSize) {\n                        const batchEnd = Math.min(batchStart + batchSize, totalRows);\n                        const batchData = [];\n                        \n                        // Process batch\n                        for (let i = batchStart; i < batchEnd; i++) {\n                            const row = new Array(cellsPerRow);\n                            \n                            for (let j = 0; j < cellsPerRow; j++) {\n                                let value;\n                                \n                                // Get value based on pre-detected format\n                                if (isArrayFormat) {\n                                    value = rows[i][j];\n                                } else if (isObjectFormat) {\n                                    value = rows[i][columns[j]];\n                                } else {\n                                    value = rows[i];\n                                }\n                                \n                                // Optimized type handling\n                                if (value == null) {\n                                    row[j] = '';\n                                } else if (typeof value === 'string') {\n                                    row[j] = value;\n                                } else if (typeof value === 'number' || typeof value === 'boolean') {\n                                    row[j] = String(value);\n                                } else if (value instanceof Date) {\n                                    row[j] = value.toISOString();\n                                } else {\n                                    try {\n                                        row[j] = JSON.stringify(value);\n                                    } catch (e) {\n                                        row[j] = String(value);\n                                    }\n                                }\n                            }\n                            batchData.push(row);\n                        }\n                        \n                        processedRows = batchEnd;\n                        \n                        // Send batch back to main thread\n                        self.postMessage({\n                            type: 'batch',\n                            data: batchData,\n                            processed: processedRows,\n                            total: totalRows,\n                            progress: Math.round((processedRows / totalRows) * 100)\n                        });\n                        \n                        // Clear batch to free memory\n                        batchData.length = 0;\n                    }\n                    \n                    // Send completion message\n                    self.postMessage({\n                        type: 'complete',\n                        processed: processedRows,\n                        total: totalRows\n                    });\n                    \n                } catch (error) {\n                    self.postMessage({\n                        type: 'error',\n                        error: error.message || String(error)\n                    });\n                }\n            };\n        "],{type:"application/javascript"}),t=URL.createObjectURL(e);return new Worker(t)},n.Feed.prototype.__processStreamingDataset=function(t,o,r,s,n){const i=this;if(!("undefined"!=typeof Worker))return i.__processStreamingDatasetFallback(t,o,r,s,n);const a=t.length>0&&Array.isArray(t[0]),l=t.length>0&&"object"==typeof t[0]&&null!==t[0]&&!Array.isArray(t[0]),c=new Array(t.length+1);c[0]=o;const u=o.length,h=(t.length,Math.min(5e6,Math.max(5e5,Math.floor(1e7/u))));if(t.length*u*50/1048576>500)return i.__processStreamingDatasetFallback(t,o,r,s,n);return(async()=>{const e=[],r=1e5;for(let s=0;s<t.length;s+=r)await new Promise((n=>{setTimeout((()=>{const i=Math.min(s+r,t.length);for(let r=s;r<i;r++)if(a)e.push(Array.from(t[r]));else if(l){const s={};for(let e=0;e<o.length;e++)s[o[e]]=t[r][o[e]];e.push(s)}else e.push(t[r]);i%5e5==0||t.length,n()}),0)}));return e})().then((function(u){return new Promise(((d,p)=>{try{const t=i.__createParquetWorker();let r=null;t.onmessage=function(o){const{type:a,data:l,processed:u,total:h,progress:f,error:g}=o.data;if("batch"===a){const e=u-l.length+1;for(let t=0;t<l.length;t++)c[e+t]=l[t];u%2e6!=0&&u!==h||performance.memory&&(Math.round(performance.memory.usedJSHeapSize/1024/1024),Math.round(performance.memory.totalJSHeapSize/1024/1024))}else if("complete"===a){t.terminate(),r&&URL.revokeObjectURL(r);try{e.duckdb.db.dropFile(s)}catch(e){}_LOG("Worker converted: "+c.length+" total rows (including header)"),i.__createDataTableObject(c,"parquet",n),d()}else if("error"===a){t.terminate(),r&&URL.revokeObjectURL(r);try{e.duckdb.db.dropFile(s)}catch(e){}p(new Error(g))}},t.onerror=function(e){t.terminate(),r&&URL.revokeObjectURL(r),p(e)},t.postMessage({rows:u,columns:o,isArrayFormat:a,isObjectFormat:l,batchSize:h})}catch(e){return i.__processStreamingDatasetFallback(t,o,r,s,n)}}))})).catch((function(t){try{e.duckdb.db.dropFile(s)}catch(e){}n&&"function"==typeof n.error&&n.error(t)}))},n.Feed.prototype.__processStreamingDatasetFallback=function(t,o,r,s,i){const a=this,l=t.length>0&&Array.isArray(t[0]),c=t.length>0&&"object"==typeof t[0]&&null!==t[0]&&!Array.isArray(t[0]),u=new Array(t.length+1);u[0]=o;const h=o.length,d=t.length*h,p=1e6;n.log(`📊 Processing ${t.length.toLocaleString()} rows (${d.toLocaleString()} cells) in batches of ${p.toLocaleString()} rows`),r&&n.log("⚡ Schema-based optimization active for faster processing");const f=async(e,s)=>new Promise((n=>{setTimeout((()=>{for(let n=e;n<s;n++)u[n+1]=a.__processRow(t[n],o,r,l,c);n()}),0)}));return(async()=>{const e=Date.now();let o=e;for(let r=0;r<t.length;r+=p){const s=Math.min(r+p,t.length);await f(r,s);const i=Date.now(),a=i-o;if(s%5e5==0||s===t.length||a>2e3){const r=((i-e)/1e3).toFixed(1),a=Math.round(s/((i-e)/1e3));let l="";if(performance.memory){l=` | Memory: ${Math.round(performance.memory.usedJSHeapSize/1024/1024)}MB / ${Math.round(performance.memory.totalJSHeapSize/1024/1024)}MB`}n.log(` ${s.toLocaleString()} / ${t.length.toLocaleString()} rows (${Math.round(s/t.length*100)}%) | ${a.toLocaleString()} rows/sec | ${r}s${l}`),o=i}}})().then((function(){_LOG("Fallback converted: "+u.length+" total rows (including header)");try{e.duckdb.db.dropFile(s)}catch(e){}a.__createDataTableObject(u,"parquet",i)})).catch((function(t){try{e.duckdb.db.dropFile(s)}catch(e){}i&&"function"==typeof i.error&&i.error(t)}))},n.Feed.prototype.__processParquetData=function(t,o){const r=this;_LOG("Processing parquet data with DuckDB WASM..."),void 0!==e.duckdb&&e.duckdbLoaded?r.__processParquetWithDuckDB(t,o):r.__loadDuckDBAndProcess(t,o)},n.Feed.prototype.__processParquetWithDuckDB=function(e,t){const o=this;_LOG("Detecting if parquet file is GeoParquet..."),o.__checkGeoParquetMetadataWithDuckDB(e,(function(r){r?(_LOG("✅ GeoParquet detected! Switching to GeoParquet processing..."),"function"==typeof o.__processGeoParquetData?o.__processGeoParquetData(e,t):(_LOG("⚠️ GeoParquet processing function not found, falling back to regular parquet processing"),o.__processWithDuckDB(e,t))):(_LOG("✅ Regular parquet file detected, proceeding with standard processing..."),o.__processWithDuckDB(e,t))}),(function(r){_LOG("⚠️ Error detecting GeoParquet, falling back to regular parquet processing: "+r),o.__processWithDuckDB(e,t)}))},n.Feed.prototype.__loadDuckDBAndProcess=function(o,r){const s=this;_LOG("Loading DuckDB WASM module dynamically...");const n=t.createElement("script");n.type="module",n.textContent='\n            // Try to load DuckDB WASM from CDN\n            let duckdb;\n            try {\n                // Try jsDelivr first (most reliable for DuckDB WASM)\n                duckdb = await import("https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@latest/+esm");\n                console.log("✅ DuckDB loaded from jsDelivr");\n            } catch (e1) {\n                try {\n                    // Fallback to ESM.sh\n                    duckdb = await import("https://esm.sh/@duckdb/duckdb-wasm@1.30.0");\n                    console.log("✅ DuckDB loaded from ESM.sh");\n                } catch (e2) {\n                    try {\n                        // Fallback to unpkg\n                        duckdb = await import("https://unpkg.com/@duckdb/duckdb-wasm@1.30.0");\n                        console.log("✅ DuckDB loaded from unpkg");\n                    } catch (e3) {\n                        throw new Error("Failed to load DuckDB from any CDN: " + e3.message);\n                    }\n                }\n            }\n            \n            console.log("DuckDB WASM module imported:", duckdb);\n            console.log("Available DuckDB methods:", Object.keys(duckdb));\n            \n            // Initialize DuckDB\n            try {\n                console.log(\'🔧 Selecting bundle from jsDelivr CDN...\');\n                const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();\n                const bundle = await duckdb.selectBundle(JSDELIVR_BUNDLES);\n                \n                console.log("👷 Creating worker from bundle...");\n                // Create worker using blob URL approach to avoid CORS issues\n                const worker_url = URL.createObjectURL(\n                    new Blob([`importScripts("${bundle.mainWorker}");`], { type: \'text/javascript\' })\n                );\n                const worker = new Worker(worker_url);\n                console.log("✅ Worker created successfully");\n                \n                const logger = new duckdb.ConsoleLogger();\n                const db = new duckdb.AsyncDuckDB(logger, worker);\n                \n                console.log("🚀 Instantiating DuckDB with WASM module...");\n                await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n                console.log("✅ DuckDB WASM instantiated successfully");\n                \n                // Revoke the blob URL to free memory\n                URL.revokeObjectURL(worker_url);\n                \n                // Create connection\n                const conn = await db.connect();\n                \n                console.log("✅ DuckDB WASM initialized successfully");\n                console.log("📊 DuckDB connection object type:", typeof conn);\n                console.log("📊 DuckDB connection methods:", Object.getOwnPropertyNames(conn));\n                console.log("📊 DuckDB connection constructor:", conn.constructor.name);\n                \n                // Store references globally\n                window.duckdb = {\n                    db: db,\n                    conn: conn,\n                    module: duckdb\n                };\n                window.duckdbLoaded = true;\n            \n            } catch (error) {\n                console.error("❌ Failed to initialize DuckDB WASM:", error);\n                window.duckdbLoadError = error;\n            }\n            ',t.head.appendChild(n);const i=setInterval((function(){e.duckdbLoaded&&e.duckdb?(clearInterval(i),_LOG("DuckDB WASM module loaded successfully"),s.__processParquetWithDuckDB(o,r)):e.duckdbLoadError&&(clearInterval(i),_LOG("Failed to load DuckDB WASM module: "+e.duckdbLoadError),void 0!==r&&r.error?r.error("Failed to load DuckDB WASM module: "+e.duckdbLoadError):a("Failed to load DuckDB WASM module: "+e.duckdbLoadError))}),100);setTimeout((function(){e.duckdbLoaded||e.duckdbLoadError||(clearInterval(i),_LOG("Timeout loading DuckDB WASM module"),void 0!==r&&r.error?r.error("Timeout loading DuckDB WASM module"):a("Timeout loading DuckDB WASM module"))}),15e3)},n.Feed.prototype.__processWithDuckDB=function(t,o){const r=this;try{if(_LOG("Processing parquet data with DuckDB WASM, buffer size: "+t.byteLength+" bytes"),n.log("🦆 Starting DuckDB parquet processing..."),t.byteLength<4)throw new Error("File too small to be a valid parquet file");const s=new Uint8Array(t),i=String.fromCharCode(...s.slice(0,4));if(_LOG("Parquet file magic number: "+i),"PAR1"!==i)throw new Error("File does not appear to be a valid parquet file (missing PAR1 magic number). Magic: "+i);_LOG("Valid parquet file detected, processing with DuckDB WASM...");const l="temp_parquet_"+Date.now()+".parquet",c=new Uint8Array(s);e.duckdb.db.registerFileBuffer(l,c).then((function(){const t=`SELECT * FROM read_parquet('${l}') LIMIT 10000000`;return e.duckdb.conn.query(t)})).then((async function(e){if(_LOG("DuckDB query result type: "+typeof e),!e)throw new Error("DuckDB query returned null/undefined");let t,s;if("function"==typeof e.toArray)t=e.toArray();else if("function"==typeof e.fetchAll)t=e.fetchAll();else if(Array.isArray(e))t=e;else{if(!e.data||!Array.isArray(e.data))throw new Error("Cannot convert DuckDB result to array. Available methods: "+Object.getOwnPropertyNames(e).join(", "));t=e.data}if(0===t.length)throw new Error("No rows found in parquet file");let i=null;if(e.schema&&e.schema.fields)s=e.schema.fields.map((e=>e.name)),i=r.__detectColumnTypes(e.schema),i&&_LOG("Schema-based optimization enabled - detected column types: "+i.join(", "));else if(e.columns)s=e.columns;else{if(!(t.length>0&&"object"==typeof t[0]))throw new Error("Cannot determine column names from DuckDB result");s=Object.keys(t[0])}if(_LOG("Extracted columns: "+s.join(", ")),0===s.length)throw new Error("No columns found in parquet file");const a=[];if(t.length>1e7)throw new Error(`Dataset too large (${t.length} rows). Maximum supported: 10,000,000 rows. Consider using a smaller LIMIT in your query.`);if(t.length>5e5&&n.log(`⚠️ Processing very large dataset (${t.length} rows). This may take a while and use significant memory.`),t.length>1e5)return n.log("📊 Large dataset detected, using streaming processing..."),r.__processStreamingDataset(t,s,i,l,o);if(t.length>5e4){const e=t.length>0&&Array.isArray(t[0]),o=t.length>0&&"object"==typeof t[0]&&null!==t[0]&&!Array.isArray(t[0]),l=s.length,c=(t.length,Math.min(2e6,Math.max(1e5,Math.floor(1e7/l))));i&&n.log("⚡ Schema-based optimization active for medium dataset");try{const l=async(n,l)=>new Promise((c=>{setTimeout((()=>{for(let c=n;c<l;c++)a.push(r.__processRow(t[c],s,i,e,o));c()}),0)})),u=Date.now();let h=u;for(let e=0;e<t.length;e+=c){const o=Math.min(e+c,t.length);await l(e,o);const r=Date.now(),s=r-h;if(o%5e5==0||o===t.length||s>2e3){const e=((r-u)/1e3).toFixed(1),s=Math.round(o/((r-u)/1e3));let i="";if(performance.memory){const e=Math.round(performance.memory.usedJSHeapSize/1024/1024);i=` | Memory: ${e}MB / ${Math.round(performance.memory.totalJSHeapSize/1024/1024)}MB`}n.log(`📊 Processing: ${o.toLocaleString()} / ${t.length.toLocaleString()} rows (${Math.round(o/t.length*100)}%) | ${s.toLocaleString()} rows/sec | ${e}s${i}`),h=r}}}catch(e){const o=t.length>0&&Array.isArray(t[0]),r=t.length>0&&"object"==typeof t[0]&&null!==t[0]&&!Array.isArray(t[0]),i=1e4,l=Date.now();let c=l;if(o)for(let e=0;e<t.length;e+=i){const o=Math.min(e+i,t.length);for(let r=e;r<o;r++){const e=new Array(s.length);for(let o=0;o<s.length;o++){const s=t[r][o];if(null==s)e[o]="";else if("string"==typeof s)e[o]=s;else if("number"==typeof s||"boolean"==typeof s)e[o]=String(s);else if(s instanceof Date)e[o]=s.toISOString();else try{e[o]=JSON.stringify(s)}catch(t){e[o]=String(s)}}a.push(e)}const r=Date.now(),u=r-c;if(o%5e4==0||o===t.length||u>2e3){const e=((r-l)/1e3).toFixed(1),s=Math.round(o/((r-l)/1e3));let i="";if(performance.memory){i=` | Memory: ${Math.round(performance.memory.usedJSHeapSize/1024/1024)}MB / ${Math.round(performance.memory.totalJSHeapSize/1024/1024)}MB`}n.log(`📊 Fallback: ${o.toLocaleString()} / ${t.length.toLocaleString()} rows (${Math.round(o/t.length*100)}%) | ${s.toLocaleString()} rows/sec | ${e}s${i}`),c=r}}else if(r)for(let e=0;e<t.length;e+=i){const o=Math.min(e+i,t.length);for(let r=e;r<o;r++){const e=new Array(s.length);for(let o=0;o<s.length;o++){const n=t[r][s[o]];if(null==n)e[o]="";else if("string"==typeof n)e[o]=n;else if("number"==typeof n||"boolean"==typeof n)e[o]=String(n);else if(n instanceof Date)e[o]=n.toISOString();else try{e[o]=JSON.stringify(n)}catch(t){e[o]=String(n)}}a.push(e)}const r=Date.now(),u=r-c;if(o%5e4==0||o===t.length||u>2e3){const e=((r-l)/1e3).toFixed(1),s=Math.round(o/((r-l)/1e3));let i="";if(performance.memory){i=` | Memory: ${Math.round(performance.memory.usedJSHeapSize/1024/1024)}MB / ${Math.round(performance.memory.totalJSHeapSize/1024/1024)}MB`}n.log(`📊 Fallback: ${o.toLocaleString()} / ${t.length.toLocaleString()} rows (${Math.round(o/t.length*100)}%) | ${s.toLocaleString()} rows/sec | ${e}s${i}`),c=r}}else for(let e=0;e<t.length;e+=i){const o=Math.min(e+i,t.length);for(let r=e;r<o;r++){const e=new Array(s.length);for(let o=0;o<s.length;o++){const s=t[r];if(null==s)e[o]="";else if("string"==typeof s)e[o]=s;else if("number"==typeof s||"boolean"==typeof s)e[o]=String(s);else if(s instanceof Date)e[o]=s.toISOString();else try{e[o]=JSON.stringify(s)}catch(t){e[o]=String(s)}}a.push(e)}const r=Date.now(),u=r-c;if(o%5e4==0||o===t.length||u>2e3){const e=((r-l)/1e3).toFixed(1),s=Math.round(o/((r-l)/1e3));let i="";if(performance.memory){i=` | Memory: ${Math.round(performance.memory.usedJSHeapSize/1024/1024)}MB / ${Math.round(performance.memory.totalJSHeapSize/1024/1024)}MB`}n.log(`📊 Fallback: ${o.toLocaleString()} / ${t.length.toLocaleString()} rows (${Math.round(o/t.length*100)}%) | ${s.toLocaleString()} rows/sec | ${e}s${i}`),c=r}}}}else{const e=t.length>0&&Array.isArray(t[0]),o=t.length>0&&"object"==typeof t[0]&&null!==t[0]&&!Array.isArray(t[0]);for(let r=0;r<t.length;r++){const n=new Array(s.length);for(let i=0;i<s.length;i++){let a;if(a=e?t[r][i]:o?t[r][s[i]]:t[r],null==a)n[i]="";else if("string"==typeof a)n[i]=a;else if("number"==typeof a||"boolean"==typeof a)n[i]=String(a);else if(a instanceof Date)n[i]=a.toISOString();else try{n[i]=JSON.stringify(a)}catch(e){n[i]=String(a)}}a.push(n)}}_LOG("Converted "+a.length+" rows with "+s.length+" columns");const c=[s];c.push(...a),r.__createDataTableObject(c,"parquet",o)})).catch((function(e){_LOG("Error in DuckDB parquet processing: "+e),void 0!==o&&o.error?o.error("Error processing parquet file with DuckDB: "+e.message):a("Error processing parquet file with DuckDB: "+e.message)})).finally((function(){try{e.duckdb.db.dropFile(l)}catch(e){}}))}catch(e){_LOG("Error in DuckDB parquet processing setup: "+e),void 0!==o&&o.error?o.error("Error setting up DuckDB parquet processing: "+e.message):a("Error setting up DuckDB parquet processing: "+e.message)}},n.Feed.prototype.__processGeoParquetData=function(o,r){const s=this;if(void 0!==e.geoparquet)_LOG("GeoParquet library already loaded, processing data..."),s.__processWithGeoParquet(o,r,e.geoparquet);else{_LOG("Loading GeoParquet library dynamically...");const n=t.createElement("script");n.type="module",n.textContent='\n                import { asyncBufferFromUrl, toGeoJson } from \'https://cdn.jsdelivr.net/npm/geoparquet@0.5.0/+esm\';\n                \n                console.log("GeoParquet module imported");\n                console.log("Available geoparquet methods:", Object.keys({ asyncBufferFromUrl, toGeoJson }));\n                \n                // Make geoparquet available globally\n                window.geoparquet = { asyncBufferFromUrl, toGeoJson };\n                window.geoparquetLoaded = true;\n            ';const i=setInterval((function(){e.geoparquetLoaded&&e.geoparquet&&(clearInterval(i),_LOG("GeoParquet module loaded successfully"),s.__processWithGeoParquet(o,r,e.geoparquet))}),100);setTimeout((function(){e.geoparquetLoaded||(clearInterval(i),_LOG("Failed to load GeoParquet module"),void 0!==r&&r.error?r.error("Failed to load GeoParquet module"):a("Failed to load GeoParquet module"))}),1e4),t.head.appendChild(n)}},n.Feed.prototype.__processWithGeoParquet=function(t,o,r){const s=this;try{if(_LOG("Processing GeoParquet data, buffer size: "+t.byteLength+" bytes"),_LOG("GeoParquet object: "+JSON.stringify(r)),_LOG("Available geoparquet methods: "+Object.keys(r).join(", ")),t.byteLength<4)throw new Error("File too small to be a valid parquet file");const n=new Uint8Array(t),i=String.fromCharCode(...n.slice(0,4));if(_LOG("Parquet file magic number: "+i),"PAR1"!==i)throw new Error("File does not appear to be a valid parquet file (missing PAR1 magic number). Magic: "+i);if(_LOG("Valid parquet file detected, processing with geoparquet..."),"function"!=typeof r.toGeoJson)throw new Error("toGeoJson method not found in geoparquet. Available methods: "+Object.keys(r).join(", "));let l;_LOG("Calling geoparquet.toGeoJson...");try{l=r.toGeoJson({file:t})}catch(r){if(r.message&&r.message.includes("non-delta field"))return _LOG("GeoParquet library failed with encoding issue, using DuckDB fallback"),e.duckdb&&e.duckdb.db?s.__processWithDuckDB(t,o):s.__loadDuckDBAndProcess(t,o);throw r}if(_LOG("GeoJSON conversion result type: "+typeof l),_LOG("GeoJSON conversion result: "+JSON.stringify(l)),l&&"function"==typeof l.then)_LOG("GeoJSON conversion is a Promise, waiting for resolution..."),l.then((function(e){try{_LOG("GeoJSON conversion completed successfully"),_LOG("GeoJSON type: "+e.type),_LOG("Number of features: "+(e.features?e.features.length:"unknown")),s.__processGeoJsonData(e,o)}catch(e){throw _LOG("Error processing GeoJSON data: "+e),new Error("Error processing GeoJSON data: "+e)}})).catch((function(r){_LOG("Error in GeoJSON conversion: "+r),_LOG("Error stack: "+r.stack),_LOG("Error message: "+r.message),r.message&&r.message.includes("non-delta field")?(_LOG("GeoParquet library failed with encoding issue, using DuckDB fallback"),e.duckdb&&e.duckdb.db?s.__processWithDuckDB(t,o):s.__loadDuckDBAndProcess(t,o)):void 0!==o&&o.error?o.error("Error converting GeoParquet to GeoJSON: "+r):a("Error converting GeoParquet to GeoJSON: "+r)}));else{if(_LOG("GeoJSON conversion returned directly"),!l)throw new Error("GeoJSON conversion returned null or undefined");_LOG("GeoJSON type: "+l.type),_LOG("Number of features: "+(l.features?l.features.length:"unknown")),this.__processGeoJsonData(l,o)}}catch(e){_LOG("Error processing GeoParquet data: "+e),void 0!==o&&o.error?o.error("Error processing GeoParquet data: "+e):a("Error processing GeoParquet data: "+e)}},n.Feed.prototype.__createDataTableObject=function(e,t,o){if(e)return this.dbtable=(new n.Table).setArray(e),e=null,void(void 0!==o&&o.success?o.success(this.dbtable):_LOG("callback to call on succes is 'undefined'!"))},n.Table=function(e){e?(this.table=e.table,this.fields=e.fields,this.records=e.records):(this.table={records:0,fields:0},this.fields=[],this.records=[])},n.Table.prototype={getArray:function(){let e=[[]];for(let t=0,o=this.fields.length;t<o;t++)e[0].push(this.fields[t].id);for(let t=0,o=this.records.length;t<o;t++)e.push(this.records[t]);return e},setArray:function(e){if(e.length<2)return this;this.fields=[];for(let t=0,o=e[0].length;t<o;t++)this.fields.push({id:(e[0][t]||" ").trim(),typ:0,width:60,decimals:0});e.shift(),this.records=[];for(let t=0,o=e.length;t<o;t++)e[t].length==this.fields.length&&this.records.push(e[t]);return this.table={records:this.records.length,fields:this.fields.length},this},revert:function(){let e=[];for(let t=this.records.length-1;t>=0;t--)e.push(this.records[t]);return this.records=e,this},reverse:function(){let e=[];for(let t=this.records.length-1;t>=0;t--)e.push(this.records[t]);return this.records=e,this},columnNames:function(){const e=[];for(let t=0,o=this.fields.length;t<o;t++)e.push(this.fields[t].id);return e},columnIndex:function(e){for(var t in this.fields)if(this.fields[t].id==e)return t;return null},column:function(e){for(let t in this.fields)if(this.fields[t].id==e){const e=new n.Column;return e.index=t,e.table=this,e}return null},lookupArray:function(e,t){let o="overwrite";e&&e.key&&(o=e.calc||o,t=e.key,e=e.value);let r=[];this.column(t)||alert("'"+t+"' column not found!"),this.column(e)||alert("'"+e+"' column not found!");const s=this.column(t).values(),n=this.column(e).values();if("sum"==o)for(let e=0,t=s.length;e<t;e++)r[String(s[e])]=(r[String(s[e])]||0)+n[e];else if("max"==o)for(let e=0,t=s.length;e<t;e++)r[String(s[e])]=Math.max(r[String(s[e])]||0,n[e]);else for(let e=0,t=s.length;e<t;e++)r[String(s[e])]=n[e];return r},lookupStringArray:function(e,t){e&&e.key&&(t=e.key,e=e.value);let o=[];this.column(t)||alert("'"+t+"' column not found!"),this.column(e)||alert("'"+e+"' column not found!");const r=this.column(t).values(),s=this.column(e).values();for(let e=0,t=r.length;e<t;e++)o[String(r[e])]=o[String(r[e])]?o[String(r[e])]+", "+s[e]:s[e];return o},lookup:function(e,t){const o=t.value,r=t.lookup,s=o+"_"+r;return this.lookupsA&&this.lookupsA[s]||(this.lookupsA=this.lookupsA||[],this.lookupsA[s]=this.lookupArray(o,r)),this.lookupsA[s][e]||"-"},toKeyValue:function(e){return this.lookupArray(e.value,e.key)},addColumn:function(e,t){if(!e.destination)return alert("'data.addColumn' no destination defined!"),null;var o=null;if(e.source){for(let t=0,r=this.fields.length;t<r;t++)this.fields[t].id==e.source&&(o=t);if(null==o)return alert("'data.addColumn' source column '"+e.source+"' not found!"),null}if(this.fields.push({id:String(e.destination),created:!0}),this.table.fields++,t&&"function"==typeof t)for(let e=0,r=this.records.length;e<r;e++)this.records[e].push(null!=o?t(this.records[e][o],this.records[e]):t(this.records[e]));else if(t&&"object"==typeof t)for(let e=0,o=this.records.length;e<o;e++)this.records[e].push(t[e]||0);else if(e.values&&"object"==typeof e.values)for(let t=0,o=this.records.length;t<o;t++)this.records[t].push(e.values[t]||0);else for(let e=0,t=this.records.length;e<t;e++)this.records[e].push(0);return this},addRow:function(e){if(!e||"object"!=typeof e)return alert("'data.addRow' no options defined!"),null;var t=[];for(let e=0,o=this.fields.length;e<o;e++)t.push("");for(var o in e)this.column(o)?t[this.column(o).index]=e[o]:alert("'data.addRow' column '"+o+"' not found!");return this.records.push(t),this.table.records++,this},filter:function(e){this.selection=new n.Table;for(const t in this.records)e&&e(this.records[t])&&(this.selection.records.push(this.records[t]),this.selection.table.records++);return this.selection.fields=this.fields.slice(),this.selection.table.fields=this.table.fields,this.selection},select:function(e){if(e.match(/WHERE/)){if(1){let t=e.split("WHERE")[1].trim().split(" ");for(let e=0;e<t.length;e++)if(t[e].length){if('"'==t[e][0]&&'"'!=t[e][t[e].length-1])do{t[e]=t[e]+" "+t[e+1],t.splice(e+1,1)}while('"'!=t[e][t[e].length-1]);if("("==t[e][0]&&")"!=t[e][t[e].length-1])do{t[e]=t[e]+" "+t[e+1],t.splice(e+1,1)}while(")"!=t[e][t[e].length-1])}else t.splice(e,1),e--;this.filterQueryA=[];let o={},r="";do{let s=0;if(t.length>=3&&(o={},o.szSelectionField=t[0].replace(/("|)/g,""),o.szSelectionOp=t[1],o.szSelectionValue=t[2].replace(/("|)/g,""),s=3),"BETWEEN"==o.szSelectionOp&&t.length>=5&&"AND"==t[3]&&(o.szSelectionValue2=t[4],s=5),!s){a("data.js - selection error - incomplete query!\nquery: "+e);break}for(let e=0;e<this.fields.length;e++)this.fields[e].id==o.szSelectionField&&(o.nFilterFieldIndex=e),"$"+this.fields[e].id+"$"==o.szSelectionValue&&(o.nFilterValueIndex=e);if(o.szCombineOp=r,this.filterQueryA.push(o),t.splice(0,s),t.length&&"AND"==t[0])r="AND",t.splice(0,1);else{if(!t.length||"OR"!=t[0])break;r="OR",t.splice(0,1)}}while(t.length)}this.selection=new n.Table;for(let t=0;t<this.filterQueryA.length;t++)if(void 0===this.filterQueryA[t].nFilterFieldIndex)return this.selection.fields=this.fields.slice(),this.selection.table.fields=this.table.fields,_LOG("Selection: invalid query: "+e),this.selection;for(let e=0,t=this.records.length;e<t;e++){let t=null;for(let o=0,r=this.filterQueryA.length;o<r;o++){let r=!0;this.__szValue=String(this.records[e][this.filterQueryA[o].nFilterFieldIndex]),this.__szSelectionOp=this.filterQueryA[o].szSelectionOp.toUpperCase(),this.__szSelectionValue=this.filterQueryA[o].szSelectionValue,this.__szSelectionValue2=this.filterQueryA[o].szSelectionValue2,this.__szCombineOp=this.filterQueryA[o].szCombineOp,null!=this.filterQueryA[o].nFilterValueIndex&&(this.__szSelectionValue=String(this.records[e][this.filterQueryA[o].nFilterValueIndex]));let s=__scanValue(this.__szValue);if("="==this.__szSelectionOp)r="*"==this.__szSelectionValue?""!=this.__szValue.replace(/ /g,""):this.__szValue==this.__szSelectionValue||s==Number(this.__szSelectionValue);else if("<>"==this.__szSelectionOp)r=!(this.__szValue==this.__szSelectionValue||s==Number(this.__szSelectionValue));else if(">"==this.__szSelectionOp)r=s>Number(this.__szSelectionValue);else if("<"==this.__szSelectionOp)r=s<Number(this.__szSelectionValue);else if(">="==this.__szSelectionOp)r=s>=Number(this.__szSelectionValue);else if("<="==this.__szSelectionOp)r=s<=Number(this.__szSelectionValue);else if("LIKE"==this.__szSelectionOp)if("*"==this.__szSelectionValue)r=this.__szValue.length;else{const e=this.__szSelectionValue.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");r=new RegExp(e,"i").test(this.__szValue)}else if("NOT"==this.__szSelectionOp){const e=this.__szSelectionValue.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");r=!new RegExp(e,"i").test(this.__szValue)}else if("IN"==this.__szSelectionOp){r=this.__szSelectionValue.split(",").map((e=>e.trim())).includes(this.__szValue)}else if("BETWEEN"==this.__szSelectionOp)r=s>=Number(this.__szSelectionValue)&&s<=Number(this.__szSelectionValue2);else{const e=this.__szSelectionValue.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");r=new RegExp(e,"i").test(this.__szValue)}t="AND"==this.__szCombineOp?t&&r:t||r}t&&(this.selection.records.push(this.records[e].slice()),this.selection.table.records++)}}return this.selection.fields=this.fields.slice(),this.selection.table.fields=this.table.fields,this.selection},aggregate:function(e,t){let o=!1;e.lead&&(o=e.calc&&"mean"==e.calc,t=e.lead,e=e.column||e.value);const r=t.split("|"),s=[];let i=null;for(let t=0;t<r.length;t++)for(let o=0;o<this.fields.length;o++)this.fields[o].id==r[t]&&(s[t]=o),this.fields[o].id==e&&(i=o);this.aggregation=new n.Table,xRecords=[],xCount=[];for(let e=0,t=this.records.length;e<t;e++){const t=[];for(let o=0,r=s.length;o<r;o++)t.push(this.records[e][s[o]]);const o=t.join("");if(xRecords[o])xRecords[o][s.length]+=__scanValue(this.records[e][i]),xCount[o][s.length]++;else{xRecords[o]=[],xRecords[o][s.length]=__scanValue(this.records[e][i]);for(let t=0;t<s.length;t++)xRecords[o][t]=this.records[e][s[t]];xCount[o]=[],xCount[o][s.length]=1}}for(let e=0,t=xRecords.length;e<t;e++)o&&(xRecords[e][s.length]/=xCount[e][s.length]),this.aggregation.records.push(xRecords[e]),this.aggregation.table.records++;const a=[];for(let e=0;e<r.length;e++)a[e]={id:r[e]};return a[r.length]={id:e},this.aggregation.fields=a,this.aggregation.table.fields=a,this.aggregation},condense:function(e,t){const o={},r=[];e&&e.lead&&(e=(t=e).lead);const s=this.columnIndex(e);if(t&&t.keep)if("string"==typeof t.keep)r[this.columnIndex(t.keep)]=!0;else for(i=0;i<t.keep.length;i++)r[this.columnIndex(t.keep[i])]=!0;const a=[];for(let e=0;e<this.records.length;e++){const n=String(this.records[e][s]);if(null!=o[n]){const s=o[n];for(let o=0,n=this.records[e].length;o<n;o++)if(!r[o])if(isNaN(this.records[e][o])){if(isNaN(this.records[e][o])&&a[s][o]!=this.records[e][o]){let e=parseFloat(String(a[s][o]).split(" (+")[1])||0;a[s][o]=String(a[s][o]).split(" (+")[0]+" (+"+ ++e+") "}}else t&&"max"==t.calc?a[s][o]=Math.max(Number(a[s][o]),Number(this.records[e][o])):a[s][o]=Number(a[s][o])+Number(this.records[e][o])}else a.push(this.records[e].slice()),o[n]=a.length-1}return this.__condense=new n.Table,this.__condense.fields=this.fields,this.__condense.table.fields=this.fields,this.__condense.records=a.slice(),this.__condense.table.records=this.__condense.records.length,this.__condense},groupColumns:function(e){let t=e.source,o=[];for(let e=0,r=t.length;e<r;e++)o[e]=this.column(t[e]).index;return this.addColumn({destination:e.destination},(function(e){let t=0;for(let r=0,s=o.length;r<s;r++)t+=Number(e[o[r]]);return t})),this},pivot:function(e){e.lead=e.lead||e.rows,e.cols=e.cols||e.columns,e.keep=e.keep||[],e.sum=e.sum||[],e.lead=r(e.lead),e.cols=r(e.cols),e.keep=r(e.keep),e.sum=r(e.sum),e.value=r(e.value),e.forced=r(e.forced);let t=[];for(let e=0;e<this.fields.length;e++)t[String(this.fields[e].id)]=e;for(let o=0,r=e.lead.length;o<r;o++)void 0===t[e.lead[o]]&&a("data.pivot - pivot keep column '"+e.lead[o]+"' not found");for(let o=0,r=e.cols.length;o<r;o++)e.cols&&void 0===t[e.cols[o]]&&a("data.pivot - pivot columns source column '"+e.cols[o]+"' not found");for(let o=0,r=e.keep.length;o<r;o++)void 0===t[e.keep[o]]&&a("data.pivot - pivot keep column '"+e.keep[o]+"' not found");for(let o=0,r=e.sum.length;o<r;o++)void 0===t[e.sum[o]]&&a("data.pivot - pivot sum column '"+e.sum[o]+"' not found");for(let o=0,r=e.value.length;o<r;o++)void 0===t[e.value[o]]&&a("data.pivot - pivot value column '"+e.value[o]+"' not found");let o=[],s=[],i=this.records;if(e.forced)for(let t=0;t<e.forced.length;t++)s[String(e.forced[t])]=0;for(let r=0,n=i.length;r<n;r++){const n=[i[r][t[e.lead[0]]]];for(let o=1;o<e.lead.length;o++)n.push(i[r][t[e.lead[o]]]);const a=n.join("|");let l=String(i[r][t[e.cols[0]]]),c=null;if("string"==e.calc)c=i[r][t[e.value[0]]];else if(c=1,e.value&&e.value.length){c=0;for(let o=0;o<e.value.length;o++)c+=e.value[o]?__scanValue(i[r][t[e.value[o]]]):1}if((!l||l.length<1)&&(l="undefined"),void 0===s[l]&&(s[l]=0),o[a]){for(let s=0;s<e.keep.length;s++)i[r][t[e.keep[s]]]&&i[r][t[e.keep[s]]].length&&o[a][e.keep[s]]!=i[r][t[e.keep[s]]]&&(o[a][e.keep[s]]=i[r][t[e.keep[s]]]);for(let s=0;s<e.sum.length;s++)o[a][e.sum[s]]+=Number(i[r][t[e.sum[s]]])}else{o[a]={Total:0};for(let s=0;s<e.keep.length;s++)o[a][e.keep[s]]=i[r][t[e.keep[s]]];for(let s=0;s<e.sum.length;s++)o[a][e.sum[s]]=Number(i[r][t[e.sum[s]]])}o[a].Total+=c,o[a][l]?(e.calc,"max"==e.calc?o[a][l]=Math.max(c,o[a][l]):(o[a][l]+=c,o[a][l+"count"]++)):(o[a][l]=c,o[a][l+"count"]=1)}this.__pivot=new n.Table;for(let t=0;t<e.lead.length;t++)this.__pivot.fields.push({id:e.lead[t]});for(let t=0;t<e.keep.length;t++)this.__pivot.fields.push({id:e.keep[t]});for(let t=0;t<e.sum.length;t++)this.__pivot.fields.push({id:e.sum[t]});if(e.cols&&e.cols.length)for(let e in s)Object.prototype.hasOwnProperty.call(s,e)&&this.__pivot.fields.push({id:e});this.__pivot.fields.push({id:"Total"});for(let t in o)if(Object.prototype.hasOwnProperty.call(o,t)){const r=[],n=t.split("|");if(e.lead&&e.lead.length)for(let e=0;e<n.length;e++)r.push(n[e]);for(let s=0;s<e.keep.length;s++)r.push(o[t][e.keep[s]]);for(let s=0;s<e.sum.length;s++)r.push(o[t][e.sum[s]]);if(e.cols&&e.cols.length)for(let n in s)Object.prototype.hasOwnProperty.call(s,n)&&("mean"==e.calc?r.push((o[t][n]||0)/(o[t][n+"count"]||1)):r.push(o[t][n]||0));r.push(o[t].Total),this.__pivot.records.push(r),this.__pivot.table.records++}return this.__pivot},subtable:function(e){if(this.__subt=new n.Table,e.fields){e.columns=[];for(let t=0;t<e.fields.length;t++)for(let o=0;o<this.fields.length;o++)this.fields[o].id==e.fields[t]&&e.columns.push(o)}for(let t=0;t<e.columns.length;t++)this.__subt.fields.push({id:String(this.fields[e.columns[t]].id)}),this.__subt.table.fields++;for(const t in this.records){let o=[];for(let r=0;r<e.columns.length;r++)o.push(this.records[t][e.columns[r]]);this.__subt.records.push(o),this.__subt.table.records++}return this.__subt},sort:function(e,t){let o=this.column(e).values(),r=0;for(let e=0;e<Math.min(o.length,10);e++)isNaN(parseFloat(String(o[e]).replace(",",".")))||r++;let s=[];if(r)for(let e=0;e<o.length;e++)s.push({index:e,value:Number(String(o[e]).replace(",","."))});else for(let e=0;e<o.length;e++)s.push({index:e,value:o[e]});t&&"DOWN"==t?s.sort((function(e,t){return e.value>t.value?-1:1})):s.sort((function(e,t){return e.value<t.value?-1:1}));let n=[];for(let e=0;e<s.length;e++)n.push(this.records[s[e].index]);return this.records=n,this},append:function(e){if(this.table.fields.length!=e.table.fields.length)return null;for(let t=0;t<this.table.fields.length;t++)if(this.table.fields[t].id!=e.table.fields[t].id)return null;let t=e.records;for(let e=0;e<t.length;e++)this.records.push(t[e]);return this.table.records=this.records.length,this},json:function(){this.__json=[];for(const e in this.records){let t={};for(const o in this.fields)t[String(this.fields[o].id)]=this.records[e][o];this.__json.push(t)}return this.__json}},__myNumber=function(e){let t=parseFloat(e.replace(/\./g,"").replace(/\,/g,"."));return isNaN(t)?0:t},__scanValue=function(e){let t=null;return String(e).match(/,/)?(t=parseFloat(String(e).replace(/\./gi,"").replace(/,/gi,".")),isNaN(t)?0:t):(t=parseFloat(String(e).replace(/ /gi,"")),isNaN(t)?0:t)},n.Table.prototype.addTimeColumns=function(e){if(!e.source)return null;for(const t in this.fields)if(this.fields[t].id==e.source){let o=e.create||["date","year","month","day","hour"];for(let e=0;e<o.length;e++)this.fields.push({id:String(o[e])}),this.table.fields++;let r=this.records.length,s=0;for(s=0;s<r;s++){let e=new Date(this.records[s][t]);if(e)for(let t=0;t<o.length;t++)switch(o[t]){case"date":let t=String(e.getDate())+"."+String(e.getMonth()+1)+"."+String(e.getFullYear());this.records[s].push(t);break;case"year":this.records[s].push(e.getFullYear());break;case"month":this.records[s].push(e.getMonth()+1);break;case"day":this.records[s].push(e.getDay());break;case"hour":this.records[s].push(e.getHours());break}}}return this},n.Column=function(){this.table=null,this.index=null,this.valueA=null},n.Column.prototype={values:function(){this.valueA=[];for(const e in this.table.records)this.valueA.push(this.table.records[e][this.index]);return this.valueA},uniqueValues:function(){this.valueA=[];for(const e in this.table.records)this.valueA.push(this.table.records[e][this.index]);return this.valueA.filter(s)},map:function(e){for(const t in this.table.records)this.table.records[t][this.index]=e(this.table.records[t][this.index],this.table.records[t],this.index);return this},rename:function(e){return this.table.fields[this.index].id=e,this},remove:function(){this.table.fields.splice(this.index,1);for(const e in this.table.records)this.table.records[e].splice(this.index,1);return this.table.table.fields--,this}},n.Feed.prototype.column=function(e){return this.dbtable.column(e)},n.Feed.prototype.select=function(e){return this.dbtable.select(e)},n.Feed.prototype.aggregate=function(e,t){return this.dbtable.aggregate(e,t)},n.Feed.prototype.revert=function(){return this.dbtable.revert()},n.Feed.prototype.reverse=function(){return this.dbtable.reverse()},n.Feed.prototype.pivot=function(e){return this.dbtable.pivot(e)},n.Feed.prototype.subtable=function(e){return this.dbtable.subtable(e)},n.Feed.prototype.addTimeColumns=function(e){return this.dbtable.addTimeColumns(e)},n.Broker=function(e){this.souceQueryA=[],this.options=e||{},e&&this.parseDefinition(e),this.onNotify=function(){},this.onError=function(e){alert("error loading data:"+e)}},n.Broker.prototype=new n.Feed,n.Broker.prototype={addSource:function(e,t){return _LOG("Data.Broker.addSource: "+e),this.souceQueryA.push({url:e,type:t,data:null,result:null,next:this}),this},setCallback:function(e){return this.callback=e,this},realize:function(e){this.callback=e||this.callback;for(const e in this.souceQueryA)if(this.souceQueryA[e].url&&!this.souceQueryA[e].result)return this.getData(this.souceQueryA[e]),this;this.data=[];for(const e in this.souceQueryA)this.data.push(this.souceQueryA[e].data||new n.Table);return this.callback(this.data),this},error:function(e){return this.onError=e||this.onError,this},notify:function(e){return this.onNotify=e||this.onNotify,this}},n.Broker.prototype.parseDefinition=function(e){this.callback=e.callback||null},n.Broker.prototype.getData=function(e){this.onNotify(e),e.feed=n.feed({source:e.url,type:e.type,options:e.next.options,parent:this}).load((function(t){e.data=t,e.data.raw=e.feed.data,this.parent.onNotify(e),e.result="success",e.next.realize()})).error((function(t){this.parent.onError(e.url),e.data=null,e.result="error",e.next.realize()}))},n.Broker.prototype.setData=function(e){this.parent.__doCreateTableDataObject(e,null,this.parent.options)},n.Feed.prototype.broker=function(e){let t=new n.Broker(e);return t.parent=this,t},n.broker=function(){return new n.Broker},n.provider=function(){return new n.Broker},n.Merger=function(e){this.sourceA=[],this.options=e||{},e&&this.parseDefinition(e)},n.Merger.prototype={addSource:function(e,t){return this.sourceA.push({data:e,opt:t}),this},setOutputColumns:function(e){return this.outColumnsA=e,this},realize:function(e){this.callback=e||this.callback,_LOG("DataMerger: >>>");let t=[];for(const e in this.sourceA){let o=this.sourceA[e];o.opt.columns=o.opt.columns||o.data.columnNames(),o.opt.label=o.opt.label||[],o.opt.columns=r(o.opt.columns),o.opt.label=r(o.opt.label),this.sourceA[e].data||a("DataMerger: source '"+e+"' not found"),this.sourceA[e].data[0]||(this.sourceA[e].data=this.sourceA[e].data.getArray()),this.sourceA[e].data[0]||a("DataMerger: source '"+e+"' not found or not of type Array");let s=[];for(const t in this.sourceA[e].data[0]){this.sourceA[e].data[0][t]==this.sourceA[e].opt.lookup&&(s[this.sourceA[e].opt.lookup]=t);for(const o in this.sourceA[e].opt.columns)this.sourceA[e].opt.label[o]||(this.sourceA[e].opt.label[o]=this.sourceA[e].opt.columns[o]+"."+(Number(e)+1)),this.sourceA[e].data[0][t]==this.sourceA[e].opt.columns[o]&&(s[this.sourceA[e].opt.label[o]]=t)}for(const t in this.sourceA[e].opt.columns)s[this.sourceA[e].opt.label[t]]||_LOG("DataMerger: '"+this.sourceA[e].opt.label[t]+"' not found");t.push(s)}let o=[];for(const e in this.sourceA)for(const t in this.sourceA[e].opt.label)o.push(this.sourceA[e].opt.label[t]);if(!this.outColumnsA){this.outColumnsA=[];for(const e in o)this.outColumnsA.push(o[e])}let s=[];for(const e in this.outColumnsA)for(const o in t)for(const r in t[o])r==this.outColumnsA[e]&&(s[r]={input:o,index:t[o][r]});for(const e in this.outColumnsA)if(!s[this.outColumnsA[e]])for(const t in this.sourceA[0].data[0])this.sourceA[0].data[0][t]==this.outColumnsA[e]&&(s[this.outColumnsA[e]]={input:0,index:t});this.namedSourceA=[];for(let e=1;e<this.sourceA.length;e++){this.namedSourceA[e]=[];for(let o=1;o<this.sourceA[e].data.length;o++)this.namedSourceA[e][String(this.sourceA[e].data[o][t[e][this.sourceA[e].opt.lookup]])]=this.sourceA[e].data[o]}let i=[];i.push(this.outColumnsA);for(let e=1;e<this.sourceA[0].data.length;e++){let o=String(this.sourceA[0].data[e][[t[0][this.sourceA[0].opt.lookup]]]),r=[];for(const t in this.outColumnsA){let n=s[this.outColumnsA[t]];if(!n)return a('DataMerger - missing "'+this.outColumnsA[t]+'" in label:[...]'),null;0==n.input?r.push(this.sourceA[0].data[e][n.index]):this.namedSourceA[n.input][o]?r.push(this.namedSourceA[n.input][o][n.index]):r.push(" ")}i.push(r)}_LOG("DataMerger: done");let l=new n.Table;return l.setArray(i),this.callback&&this.callback(l),l},error:function(e){return this.onError=e||this.onError,this}},n.merger=function(){return new n.Merger};var a=function(e){}}(window,document);